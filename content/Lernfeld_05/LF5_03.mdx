---
title: "Prozesse der Softwareentwicklung"
description: "Von der digitalen Audiodatenverarbeitung bis zu Vorgehensmodellen: Sampling, Datenschutz, Speicherarten, SDLC und agile Methoden im Überblick."
tags: ["LF5", "Softwareentwicklung", "Sampling", "Datenschutz", "Vorgehensmodelle", "Scrum", "DevOps"]
---


## Digitalisierung von Audio

Töne werden physikalisch als Schwingungslinien dargestellt. Eine Schwingungslinie bezeichnet man auch als **Signal**.

---

## Sampling-Rate

Die **Sampling-Rate** (Abtastrate) gibt an, wie oft das Signal in einer Sekunde abgetastet wird.

- Beispiel: 6 Abtastungen pro Sekunde = 6 Hz
- Übliche Sampling-Rate z. B. 44.100 Hz = 44,1 kHz

---

## Sampling-Tiefe

Auf der y-Achse wird die Tonhöhe (Amplitude) erfasst. Nicht jeder Wert kann gespeichert werden → Rundung notwendig.

- Bei **3 Bit**: $$2^3 = 8$$ verschiedene Werte
- Bei **16 Bit**: $$2^{16} = 65.536$$ Werte

---

## Diskretisierung

Ein Analog-Digital-Wandler (**AD-Wandler**) überträgt ein analoges Signal in ein digitales Raster.

- Je höher Samplingtiefe und Samplingrate, desto feiner das Raster → bessere Qualität

---

## Datenrate und Datenmenge

- **Datenrate**:  
  $$\text{Samplingtiefe} \times \text{Samplingrate}$$ 
  Einheit: bit/s, kbit/s, Mbit/s

- **Datenmenge**:  
  $$\text{Datenrate} \times \text{Zeit (s)}$$

**Beispiel:**  
- 3 Bit, 6 Abtastungen/s → $$6 \times 3 = 18$$ Bit/s  
- Dauer: 3 Minuten  
  → $$18~\text{bit/s} \times 180~\text{s} = 3240~\text{bit} = 405~\text{Byte}$$

---

## Praxisbeispiel Tonstudio

**Gegeben:**  
- 24 Bit, 48.000 Hz  
- Dauer: 30 Minuten

**Speicherplatz:**  
$$24 \times 48.000 \times 60 \times 30 = 2.073.600.000~\text{Bit} = 259{,}2~\text{MB}$$

**Datenrate:**  
$$24 \times 48.000 = 1.152.000~\text{Bit/s} = 144~\text{kB/s}$$

---

## Codec G.711 (VoIP)

**Gegeben:**  
- Samplingtiefe: 8 Bit  
- Datenrate: 64 kbit/s

**Samplingrate:**  
$$\frac{64.000}{8} = 8.000~\text{Hz} = 8~\text{kHz}$$

---

## Algorithmen und Programme

> **Algorithmus:** Handlungsvorschrift zur schrittweisen Problemlösung

Beispiel:
- Euklidischer Algorithmus → Programm (Quellcode)  
- Compiler → Maschinenbefehle (Binärcode) → Prozessor

---

## Klassifikation von Daten

| Kriterium        | Werte                              |
|------------------|-------------------------------------|
| Repräsentation   | analog, digital                     |
| Struktur         | strukturiert, semistrukturiert, unstrukturiert |
| Sicherheitsstufe | öffentlich, intern, vertraulich, geheim |
| Beständigkeit    | dauerhaft, flüchtig                |

---

## Datenquellen

**Intern:**  
- Mitarbeitende  
- Berichte  
- Bestell- und Lagerstatistik

**Extern:**  
- Kunden, Anbieter, Umfragen  
- Datenanbieter

**Datentypen:**  
- Primärdaten (selbst erhoben)  
- Sekundärdaten (vorhanden, ggf. veraltet)

---

## Datenschutz, Datensicherheit und Informationssicherheit

- **Datenschutz:**  
  Schutz personenbezogener Daten, Recht auf informationelle Selbstbestimmung

- **Datensicherheit:**  
  Schutz aller Daten (auch nicht-personenbezogen) vor Manipulation oder Verlust

- **Informationssicherheit:**  
  Technisch-organisatorische Maßnahmen zur Sicherstellung von:
  - Vertraulichkeit
  - Integrität
  - Verfügbarkeit

---

## Schutzziele

- **Vertraulichkeit:** nur autorisierte Zugriffe  
- **Integrität:** Daten bleiben korrekt und unverändert  
- **Verfügbarkeit:** Daten sind bei Bedarf erreichbar

---

## Dezimale vs. binäre Dateneinheiten

| Einheitstyp | Beispiele                    | Umrechnung                        |
|-------------|------------------------------|-----------------------------------|
| Dezimal     | KB, MB, GB, TB               | 1 KB = 1000 B, 1 MB = 1000 KB     |
| Binär       | KiB, MiB, GiB, TiB           | 1 KiB = 1024 B, 1 MiB = 1024 KiB  |

---

## Beispiel: Speicherbedarf für Bilder

**Gegeben:**  
- 500 Bilder  
- 1500 × 2000 Pixel  
- 3 Farbkanäle (RGB), 8 Bit/Kanal

**Rechnung:**

1. Pixel pro Bild: $1500 \times 2000 = 3.000.000$  
2. Byte pro Bild: $3.000.000 \times 3 = 9.000.000$  
3. Gesamt: $9.000.000 \times 500 = 4.500.000.000$ Byte  
4. Umrechnung:  
   $4.500.000.000 / 1024^3 \approx 4,19~\text{GiB}$

---

## Speicherlösungen

- **Cloud-Storage:** Online-Zugriff, zentral verwaltet  
- **Full-Flash-Storage:** Nur SSDs, schnelle Zugriffe  
- **All-/Hybrid-Flash:** Kombination mit klassischen Festplatten

**Weitere Formen:**

- **File-Storage:** Hierarchisch, Dateibasiert  
- **Block-Storage:** Blockbasiert, performant für Datenbanken  
- **Object-Storage:** Objekte mit Metadaten und ID, auch als Serialisierung bezeichnet

---

## Software Engineering

> Ziel: **Qualitätssoftware effizient und zuverlässig entwickeln**

- Fehler vermeiden  
- Aufwand minimieren  
- Kundennutzen maximieren  
- Lebenszyklus managen

---

## Software-Lebenszyklus (SDLC)

1. Anforderungsanalyse  
2. Entwurf  
3. Implementierung  
4. Test  
5. Auslieferung  
6. Wartung & Support

---

## IEEE 12207 – Softwareentwicklungsphasen

### Teil 1

- **Anforderungsanalyse:** Was soll die Software leisten?  
- **Entwurfsphase:** Modelle und Design  
- **Implementierung:** Quellcodeerstellung  
- **Testen:** Testfälle vs. Anforderungen

### Teil 2

- **Dokumentation:** kontinuierlich (z. B. User Manual)  
- **Auslieferung:** Bereitstellung, ggf. Schulung  
- **Wartung & Support:** Patches, Updates, Erweiterungen

---

## Projektmanagement-Aufgaben

- Zieldefinition (Inhalt, Kosten, Zeit)  
- Risikoanalyse  
- Ressourcenprüfung  
- Grobplanung  
- Kommunikation (intern/extern)  
- Qualitätsmanagement  
- Personalorganisation

---

## Risikofaktoren

- Fehlende Analyse  
- Schlechtes Management  
- Technische Probleme  
- Personalmangel  
- Dokumentationslücken  
- Dritte, rechtliche Risiken  
- Kommunikationsmängel

---

## Vorgehensmodelle: Klassisch

### Wasserfallmodell

**Vorteile:**
- Klare Phasen  
- Planbarkeit von Kosten/Zeit

**Nachteile:**
- Geringe Flexibilität  
- Anforderungen ändern sich oft

---

### V-Modell

- Gegenüberstellung von Entwicklungs- und Testphasen  
- Testen erfolgt mit wachsender Detaillierung

```
Anforderungsanalyse ↔ Abnahmetest
Systementwurf        ↔ Systemtest
Softwaredesign       ↔ Integrationstest
Moduldesign          ↔ Modultest
```

---

## Agile Vorgehensmodelle

- **Iterativ:** In Zyklen (Sprints)  
- **Inkrementell:** Schrittweise lieferbar  
- **Kundenorientiert**  
- **Flexibel gegenüber Änderungen**  
- **Selbstorganisierende Teams**  
- **Kontinuierliche Verbesserung**

---

## Scrum

| Rolle          | Aufgaben                                                  |
|----------------|-----------------------------------------------------------|
| Product Owner  | Projektziele, Kundenziele, hält sich aus Umsetzung raus   |
| Scrum Team     | 5–9 Personen, selbstorganisiert, Sprint-Ziele definieren  |
| Scrum Master   | Produktivität sichern, Hindernisse beseitigen             |

---

## DevOps

- Kunstwort aus **Development** + **Operations**
- Entwickler und Betreiber arbeiten eng zusammen
- Keine funktionale Trennung
- Ziel: Effizienz, Qualität, schnelle Auslieferung

---

## Fazit

LF5.3 vermittelt zentrale Aspekte zur Digitalisierung, Verarbeitung, Strukturierung und zum Schutz von Daten sowie den gesamten Prozess der Softwareentwicklung – von klassischen bis zu agilen Modellen. Das Verständnis von Speicheranforderungen, Sicherheitszielen und Projektmethodik ist essenziell für die Entwicklung praxisrelevanter und zukunftssicherer IT-Lösungen.
